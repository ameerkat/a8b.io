<html>
    <head>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-126051187-1"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-126051187-1');
        </script>

        <title>a8b.io</title>
        <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="../../index.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css">
        <link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- MathJax -->
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

        <!-- <link rel="stylesheet" href="./vtvt/vtvt_demo_styles.css"> -->
        <script type="text/javascript" src="./vtvt/vtvt.js"></script>

        <style type="text/css">
            .canvas-wrapper { text-align: center; }
            .canvas-wrapped { width: 400px; height: 400px; }
            .canvas-caption-wrapper { text-align: center; }
            .canvas-caption { font-style: italic; background-color: #F5F2CA; }
            .code {
                font-family: 'Courier New', Courier, monospace;
                background-color: #eee;
                padding: 3px;
            }
        </style>
    </head>
    <body>
        <div class="main-wrapper">
            <div class="header-wrapper">
                <h1 class="title"><a href="../../index.html">a8b.io</a></h1>
            </div>
            <div class="content-wrapper">
                <div class="content-header-wrapper">
                    <span class="up-nav">
                        <a href="./index.html">All Posts</a>
                    </span>
                    <span class="social-item">Follow me on twitter <a href="https://twitter.com/AmeerNAyoub"><img src="../../images/mini_me.jpg" class="mini-profile-image" />@AmeerNAyoub</a></span>
                </div>
                <div class="post column-container" id="principles-1">
                    <div class="left">
                        <div class="post-title">
                            <h1>Linear Algebra for Machine Learning: An Interactive Visual Introduction</h1>
                            <span class="post-date">October X, 2020</span>
                        </div>
                        <div class="post-content">
                            <h2 id="introduction">Introduction</h2>
                            <p>This post is an interactive visual introduction to the linear algebra concepts that are useful for machine learning. There will <i>not</i> be a focus on formulas, rather a focus on what these concepts mean and how they are utilized in machine learning. A great (and longer) introduction that is more generic in scope and purpose but similar in its focus on concepts over computation is <a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">3blue1brown's essence of linear algebra video series</a> which is highly recommended for those who want to know more about linear algebra in general without rigorous formality. A more technical but still applied resource is the book <a href="https://mml-book.github.io/">Mathematics for Machine Learning</a> which is available online for free. Chapter 2 focuses on Linear Algebra. This post is built on <a href="https://www.expunctis.com/2019/01/11//vtvt-demo.html">vtvt</a> from Ilya Perederiy. The visual examples are all 2d but all properties apply to higher dimensions as well.</p>

                            <h2 id="scalars-vectors-matrices">Vectors, Scalars, Matrices, and Tensors</h2>
                            <h3 id="vectors">Vectors</h3>
                            <p>
                               A vector is simply a 1-dimensional array of numbers like <span class="code">x = [1, 2, 3, ...]</span>. There is a specific order to the numbers and we can refer to individual elements through an index like <span class="code">x[0] = 1</span>. You can interpet a vector as a specific point in space, where each number of the vector is the length along an axis. When we draw them we usually show an arrow pointing to the coordinates starting from the origin. In machine learning applications you can think of an individual sample in our data set as a vector in "feature space", with each axis representing a feature and the value along that axis as the numerical value of the feature. Features always end up getting represented numerically to perform computations on them. Things like categorical features (for example a weather feature with values "sunny", "cloudy", etc.) get transformed to a number ("sunny" → 0, "cloudy" → 1, etc.) via a process called feature encoding. There are many ways to encode categorical features to numbers with one of the most popular being <a href="https://machinelearningmastery.com/why-one-hot-encode-data-in-machine-learning/">One-Hot encoding</a>, for examples of different encoding methods you can refer to the Kaggle notebook <a href="https://www.kaggle.com/prashanththangavel/advanced-feature-engineering-feature-encoding">"Advanced Feature Engineering - Feature Encoding"</a>.
                            </p>
                    
                            <div class="canvas-wrapper">
                                <canvas id='single-vector' class="canvas-wrapped"></canvas>
                            </div>
                            <div class="canvas-caption-wrapper">
                                <span class="canvas-caption">Figure 1.1. A lone vector.</span>
                            </div>
                            <script>
                                const scene1 = new vtvt({canvas_id: "single-vector", grid_res: 16, circle_rad: 0.5, show_matrix: false, show_eig: false});
                                scene1.addVector({coords: [2, 3], c: "86, 70, 110", draggable: true, kind: 'vector', label: "v = @", draw_point: true});
                                scene1.render();
                            </script>
                    
                            <p>
                               When adding two vectors you simply chain them tip to tail, which is where the arrow notation makes visual sense. Computationally, vector addition is simply element wise addition.
                            </p>

                            <div class="canvas-wrapper">
                                <canvas id='vector-addition' class="canvas-wrapped"></canvas>
                            </div>
                            <div class="canvas-caption-wrapper">
                                <span class="canvas-caption">Figure 1.2. Vector addition in action. The gray arrow is identical to w.</span>
                            </div>
                            <script>
                                const scene2 = new vtvt({canvas_id: "vector-addition", grid_res: 16, circle_rad: 0.5, show_matrix: false, show_eig: false});
                                scene2.addVector({coords: [2, 3], c: "86, 70, 110", draggable: true, kind: 'vector', label: "v = @", draw_point: true});
                                scene2.addVector({coords: [-5, 1], c: "0, 160, 190", draggable: true, kind: 'vector', label: "w = @"});
                                scene2.addVector({coords: [-5, 1], c: "200,200,200", draggable: true, kind: 'vector', map_coords: function(){ 
                                    return { mapX: scene2.vectors[1].coord_x,
                                            mapY: scene2.vectors[1].coord_y,
                                            mapXo: scene2.vectors[0].coord_x,
                                            mapYo: scene2.vectors[0].coord_y}}});    
                                scene2.addVector({c: "190,160,0", draggable: true, kind: 'vector', draggable: false, label: "v + w = @", map_coords: function(){ 
                                        return { mapX: scene2.vectors[0].coord_x + scene2.vectors[1].coord_x, 
                                                mapY: scene2.vectors[0].coord_y + scene2.vectors[1].coord_y }}});
                                scene2.render();
                            </script>
                    
                            <h3 id="scalars">Scalars</h3>
                            <p>
                                Scalars are simply numbers (like <span class="code">2</span>, <span class="code">-4</span>, or <span class="code">314159.3</span>). In linear algebra they're called scalars because when you multiply a vector by a scalar they "scale" that vector as if I were resizing it by that factor while keeping it on the same line. Positive scalars scale the vector in the same direction, while negative scalars flip the vector in the opposite direction. When you multiply a vector by a scalar you simply multiply all the elements of the vector by the scalar.
                            </p>
                            <div class="canvas-wrapper">
                                <canvas id='scalar-multiplication' class="canvas-wrapped"></canvas>
                            </div>
                            <!-- todo do a slider instead of a input box -->
                            <script>
                                function render_scalar() {
                                    const scalar = (document.getElementById("scalar-multiplication-factor") && document.getElementById("scalar-multiplication-factor").value) || 2;
                                    const scene3 = new vtvt({canvas_id: "scalar-multiplication", grid_res: 32, circle_rad: 0.5, show_matrix: false, show_eig: false});
                                    scene3.addVector({coords: [scalar * 2, scalar * 3], c: "86, 70, 110", draggable: false, kind: 'vector', label: `${scalar}*v = @`, draw_point: true});
                                    scene3.render();
                                }
                                
                                render_scalar();
                            </script>
                            <div class="canvas-caption-wrapper">
                                <span class="canvas-caption">Figure 1.3. The vector v = [2, 3] multiplied by the scalar <input id="scalar-multiplication-factor" type="text" placeholder="2" style="width: 30px;" onKeyUp="render_scalar()"></input></span>
                            </div>

                            <h3 id="unit-vectors">Unit Vectors</h3>
                            <p>A unit vector is a vector with a length of 1. There are some special names for unit vectors that run parallel to the coordinate axes. We call the vector of length 1 in the x direction  <span class="code">î</span> (pronounced "i hat"), and the vector of length 1 in the y direction <span class="code">ĵ</span> ("jay hat").</p>

                            <div class="canvas-wrapper">
                                <canvas id='unit-vectors-canvas' class="canvas-wrapped"></canvas>
                            </div>
                            <div class="canvas-caption-wrapper">
                                <span class="canvas-caption">Figure 1.4. The unit vectors in the x and y directions.</span>
                            </div>
                            <script>
                                const scene4 = new vtvt({canvas_id: "unit-vectors-canvas", grid_res: 4, circle_rad: 0.5, show_matrix: false, show_eig: false, label_font: '24px Arial'});
                                scene4.addVector({coords: [1, 0], c: "86, 70, 110", draggable: false, kind: 'vector', label: "î = @", draw_point: true});
                                scene4.addVector({coords: [0, 1], c: "0, 160, 190", draggable: false, kind: 'vector', label: "ĵ = @", draw_point: true});
                                scene4.render();
                            </script>

                            <h3 id="basis-vectors">Basis Vectors</h3>
                            <p>Generally speaking numbers can have units associated with them. Angles can be measured in degrees or in radians for example. The idea of "each number of the vector is the length along an axis" is only half way to the truth. Each individual element of a vector is a scalar applied to some <i>basis vector</i> rather than just a number along the number line of an axis. A vector is just the combination/sum of some scaled basis vectors the same way a coordinate is the combination of the x and y components. When we don't mention any special set of basis vectors (collectively just called a <i>basis</i>) then the unit vectors (for example î and ĵ in 2 dimensions) I mentioned earlier are the basis vectors. Just as it can be useful both narratively and computationally to represent an angle in radians compared to degrees it can be useful to represent vectors in different bases on ocassion (such as in Principal Component Analysis which will be described later). As an example of how a vector is a composition of scaled basis vectors you can think of <span class="code">a = [7, 2]</span> as <span class="code">a = 7î + 2ĵ</span>. Understanding how a vector is a composition of scaled basis vectors is important because of the way the columns of a matrix contain mapping information for the basis vectors during multiplication.</p>

                            <div class="canvas-wrapper">
                                <canvas id='basis-vector-addition' class="canvas-wrapped"></canvas>
                            </div>
                            <div class="canvas-caption-wrapper">
                                <span class="canvas-caption">Figure 1.5. A vector as represented by a composition of basis vectors.</span>
                            </div>
                            <script>
                                const scene5 = new vtvt({canvas_id: "basis-vector-addition", grid_res: 16, circle_rad: 0.5, show_matrix: false, show_eig: false});
                                scene5.addVector({coords: [2, 3], c: "86, 70, 110", draggable: true, kind: 'vector', label: "v = @", draw_point: true});
                                scene5.addVector({coords: [2, 0], c: "0, 160, 190", draggable: true, kind: 'vector', label: "@[x]î", map_coords: function(){ 
                                    return { mapX: scene5.vectors[0].coord_x, mapY: 0, mapXo: 0, mapYo: 0}}});
                                scene5.addVector({coords: [0, 3], c: "0, 160, 190", draggable: true, kind: 'vector', label: "@[y]ĵ", map_coords: function(){ 
                                    return { mapX: 0, mapY: scene5.vectors[0].coord_y, mapXo: 0, mapYo: 0}}});

                                scene5.render();
                            </script>

                            <h3 id="matrices">Matrices</h3>
                            <p>
                                A matrix is a 2-dimensional array of numbers.
                                
                                <div class="canvas-wrapper">
                                    <math>
                                        <mrow>
                                            <mo> [ </mo>
                                            <mtable>
                                            <mtr>
                                                <mtd> <mn>3</mn> </mtd>
                                                <mtd> <mn>7</mn> </mtd>
                                                <mtd> <mn>1</mn> </mtd>
                                            </mtr>
                                            <mtr>
                                                <mtd> <mn>0</mn> </mtd>
                                                <mtd> <mn>1</mn> </mtd>
                                                <mtd> <mn>1</mn> </mtd>
                                            </mtr>
                                            <mtr>
                                                <mtd> <mn>9</mn> </mtd>
                                                <mtd> <mn>0</mn> </mtd>
                                                <mtd> <mn>1</mn> </mtd>
                                            </mtr>
                                            </mtable>
                                            <mo> ] </mo>
                                        </mrow>
                                    </math>
                                </div>
                                <div class="canvas-caption-wrapper">
                                    <span class="canvas-caption">Figure 1.6. A 3x3 matrix.</span>
                                </div>

                                When writing code in numpy, pytorch or most other libraries they are written row by row like <span class="code">a = numpy.matrix([[3, 7, 1], [0, 1, 1], [9, 0, 1]])</span>. You would index them similar to how you would an array of arrays, first the row and then the column starting at 0 for the first element. <span class="code">a[0, 1]</span> would be the 0th row (<span class="code">[3, 7, 1]</span>) and then the element at index 1 (the second item since we start at 0) which is <span class="code">7</span>.
                            </p>
                                <!-- Go into how a weight matrix works then in a neural net -->

                            <h4>Matrix Multiplication</h4>
                            <p>
                            The elements of a matrix have an interpretation beyond just that of an arbitrary collection of numbers. A matrix when multiplied by a vector behaves like a transformation of space. Each column of the matrix describes where one of the basis vectors goes in the transformation. For example let's look at the matrix <span class="code">[[0, 1], [-1, 0]]</span>. While we write out matrices row by row it will be easier to look at the matrix column by column.
                            </p>

                            <div class="canvas-wrapper">
                                <math>
                                    <mrow>
                                        <mo> [ </mo>
                                        <mtable>
                                        <mtr>
                                            <mtd> <mn>0</mn> </mtd>
                                            <mtd> <mn>1</mn> </mtd>
                                        </mtr>
                                        <mtr>
                                            <mtd> <mn>-1</mn> </mtd>
                                            <mtd> <mn>0</mn> </mtd>
                                        </mtr>
                                        </mtable>
                                        <mo> ] </mo>
                                    </mrow>
                                </math>
                            </div>
                            <div class="canvas-caption-wrapper">
                                <span class="canvas-caption">Figure 1.7. The matrix [[0, 1], [-1, 0]].</span>
                            </div>

                            <p>The first column <math><mrow><mo>[</mo><mtable><mtr><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>-1</mn></mtd></mtr></mtable><mo>]</mo></mrow></math> tells where î will go to, and the <math><mrow><mo>[</mo><mtable><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd></mtr></mtable><mo>]</mo></mrow></math> tells where ĵ will go.</p>

                            <div class="canvas-wrapper">
                                <canvas id='matrix-multiplication-1' class="canvas-wrapped"></canvas>
                            </div>
                            <div class="canvas-caption-wrapper">
                                <span class="canvas-caption">Figure 1.8. The matrix [[0, 1], [-1, 0]] transforming space.</span>
                            </div>
                            <script>
                                let rotationAmountDegrees = 0;

                                function draw() {
                                    rotationAmountDegrees += 1;
                                    if (rotationAmountDegrees >= 160) {
                                        rotationAmountDegrees = 0; // reset
                                    }

                                    const rotationToUse = rotationAmountDegrees > 90 ? 90 : rotationAmountDegrees;
                                    
                                    const scene6 = new vtvt({canvas_id: "matrix-multiplication-1", grid_res: 4, circle_rad: 0.5, show_matrix: false, show_eig: false, 
                                    label_font: '24px Arial',
                                    context_callback: function(canvas, ctx) {
                                        //ctx.setTransform(1, 0, 0, 1, 0, 0);
                                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                                        // TODO note whether or not to use 4 or 2 here seems platform dependent?
                                        // how do we choose. On laptop it's 4
                                        ctx.translate(canvas.width / 2, canvas.height / 2);
                                        ctx.rotate(rotationToUse * Math.PI / 180);
                                        ctx.translate(-1 * canvas.width / 2, -1 * canvas.height / 2);
                                    }});

                                    scene6.addVector({coords: [1, 0], c: "86, 70, 110", draggable: false, kind: 'vector', label: "î", draw_point: true});
                                    scene6.addVector({coords: [0, 1], c: "0, 160, 190", draggable: false, kind: 'vector', label: "ĵ", draw_point: true});
                                    scene6.render();
                                }

                                setInterval(draw, 10);
                            </script>

                            <p>Observing how the unit vectors are transformed shows that this matrix describes a 90 degree clockwise rotation. When multiplying this matrix with a vector, we can simply sum the scaled new vectors ([0, -1] and [1, 0]) the same way we summed the scaled up basis vectors in the section on basis vectors. For example the vector <span class="code">[3, 7]</span> when multiplied by <span class="code">[[0, 1], [-1, 0]]</span>.</p>

                            <div class="canvas-wrapper">
                                <math>
                                    <mrow>
                                        <mo> [ </mo>
                                        <mtable>
                                        <mtr>
                                            <mtd> <mn>0</mn> </mtd>
                                            <mtd> <mn>1</mn> </mtd>
                                        </mtr>
                                        <mtr>
                                            <mtd> <mn>-1</mn> </mtd>
                                            <mtd> <mn>0</mn> </mtd>
                                        </mtr>
                                        </mtable>
                                        <mo> ] </mo>
                                    </mrow>
                                    <mrow>
                                        <mo> [ </mo>
                                        <mtable>
                                        <mtr>
                                            <mtd> <mn>3</mn> </mtd>
                                            <mtd> <mn>7</mn> </mtd>
                                        </mtr>
                                        </mtable>
                                        <mo> ] </mo>
                                    </mrow>
                                    <mrow>
                                        <mo> = 3 </mo>
                                        <mo> [ </mo>
                                        <mtable>
                                        <mtr>
                                            <mtd> <mn>0</mn> </mtd>
                                        </mtr>
                                        <mtr>
                                            <mtd> <mn>-1</mn> </mtd>
                                        </mtr>
                                        </mtable>
                                        <mo> ] </mo>
                                    </mrow>
                                    <mrow>
                                        <mo> + 7 </mo>
                                        <mo> [ </mo>
                                        <mtable>
                                        <mtr>
                                            <mtd> <mn>1</mn> </mtd>
                                        </mtr>
                                        <mtr>
                                            <mtd> <mn>0</mn> </mtd>
                                        </mtr>
                                        </mtable>
                                        <mo> ] </mo>
                                    </mrow>
                                    <mrow>
                                        <mo> = </mo>
                                        <mo> [ </mo>
                                        <mtable>
                                        <mtr>
                                            <mtd> <mn>7</mn> </mtd>
                                            <mtd> <mn>-3</mn> </mtd>
                                        </mtr>
                                        </mtable>
                                        <mo> ] </mo>
                                    </mrow>
                                </math>
                            </div>
                            <div class="canvas-caption-wrapper">
                                <span class="canvas-caption">Figure 1.9. [3, 7] multiplied by [[0, 1], [-1, 0]].</span>
                            </div>
                            <br />

                            <div class="canvas-wrapper">
                                <canvas id='matrix-multiplication-2' class="canvas-wrapped"></canvas>
                            </div>
                            <div class="canvas-caption-wrapper">
                                <span class="canvas-caption">Figure 1.10. v multiplied by [[0, 1], [-1, 0]].</span>
                            </div>
                            <script>
                                const scene7 = new vtvt({canvas_id: "matrix-multiplication-2", grid_res: 20, circle_rad: 0.5, show_matrix: false, show_eig: false});
                                scene7.addVector({coords: [4, 1], c: "86, 70, 110", draggable: true, kind: 'vector', label: "v = @", draw_point: true});
                                scene7.addVector({coords: [2, 0], c: "0, 160, 190", draggable: false, kind: 'vector', label: "[[0, 1], [-1, 0]]*v = @", map_coords: function(){ 
                                    return { mapX: scene7.vectors[0].coord_y, mapY: -1 * scene7.vectors[0].coord_x, mapXo: 0, mapYo: 0}}});

                                scene7.render();
                            </script>

                            <p>Each element of the vector being multiplied needs to correspond to a column of the matrix therefore for a matrix multiplication to be valid the number of elements in the vector and the number of columns in the matrix needs to match. You can also multiply two matrices together, which acts as chaining the transformations together in sequence. When multiple matrix multiplications are involved the rightmost / innermost one takes effect first just like when nesting functions.</p>

                            <h3>Tensors</h3>
                            <p>A tensor is a generalization of scalars, vectors, and matrices. A 0-dimensional tensor is a scalar, a 1-dimensional tensor is a vector, and a 2-dimensional tensor is a matrix. Some libraries such as PyTorch and Tensorflow don't have individual concepts for vectors and matrices and combine them generically into a tensor. For example a matrix in PyTorch could be represented as <span class="code">x = torch.tensor([[1, 2, 3], [4, 5, 6]])</span></p>

                            <h2>Application: Neural Network Weight Matrix</h2>
                            <!-- todo include a picture of the network -->
                            Neural networks in machine learning are networks of computational "nodes". Each node performs some computation based on its inputs and produces an output. The function each node performs is usually fixed, and the functions you use and the way you wire up these functions is collectively known as the architecture of the neural network. What the computer learns at training time is actually a <b>weight matrix</b> that transforms the input to each node. The weight matrix is "learned" is through back propagation. Error is calculated by taking the difference between some known label and what the network predicted. We then take really small steps to change the weight matrices to minimize the error. We know which way to take those steps based on calculating the derivative.
                        </div>
                        <div class="post-tags">
                            <ul>
                                <li>#linear-algebra #deep-learning #machine-learning</li>
                            </ul>
                        </div>
                    </div>
                    <div class="right">
                        <div class="post-toc">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- TOC Bot -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
        <script type="text/javascript">
            for (post of document.getElementsByClassName('post')) {
                const identifier = post.getAttribute("id");

                tocbot.init({
                    tocSelector: `#${identifier} .post-toc`,
                    contentSelector: `#${identifier} .post-content`,
                    headingSelector: 'h1, h2, h3',
                    hasInnerContainers: true,
                });
            }
        </script>
    </body>
</html>
